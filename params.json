{"name":"Clump","tagline":"A library for expressive and efficient service composition","body":"* [Introduction](#introduction) \r\n* [Getting started](#getting-started)\r\n* [Usage](#usage)\r\n  * [Example](#example)\r\n  * [Sources](#sources)\r\n  * [Constants](#constants)\r\n  * [Composition](#composition)\r\n  * [Execution](#execution)\r\n  * [Composition behavior](#composition-behavior)\r\n  * [Filtering](#filtering)\r\n  * [Exception handling](#exception-handling)\r\n  * [Scala Futures](#scala-futures)\r\n* [Internals](#internals)\r\n* [Known limitations](#known-limitations)\r\n* [Acknowledgments](#acknowledgments)\r\n* [Versioning](#versioning)\r\n* [License](#license)\r\n\r\n# Introduction #\r\n\r\n## Summary ##\r\n\r\nClump is a __Scala__ library that addresses the problem of knitting together data from multiple sources in an elegant and efficient way.\r\n\r\nIn a typical microservice-powered system, it is common to find awkward wrangling code to facilitate manually bulk-fetching\r\ndependent resources. Worse, this problem of batching is often accidentally overlooked, resulting in **n** calls to a micro-service instead of **1**.\r\n\r\nClump removes the need for the developer to even think about bulk-fetching, batching and retries, providing a powerful and composable interface for aggregating resources.\r\n\r\nAn example of batching fetches using futures without Clump:\r\n\r\n```scala\r\ntracksService.get(trackIds).flatMap { tracks =>\r\n  val userIds = tracks.map(_.creator)\r\n  usersService.get(userIds).map { users =>\r\n    val userMap = userIds.zip(users).toMap\r\n    tracks.map { track =>\r\n      new EnrichedTrack(track, userMap(track.creator))\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe same composition using Clump:\r\n\r\n```scala\r\nClump.traverse(trackIds) { trackId =>\r\n  trackSource.get(trackId).flatMap { track =>\r\n    userSource.get(track.creator).map { user =>\r\n      new EnrichedTrack(track, user)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nOr expressed more elegantly with a for-comprehension:\r\n\r\n```scala\r\nClump.traverse(trackIds) { trackId =>\r\n  for {\r\n    track <- trackSource.get(trackId)\r\n    user <- userSource.get(track.creator)\r\n  } yield {\r\n    new EnrichedTrack(track, user)\r\n  }\r\n```\r\n\r\n\r\n## Problem ##\r\n\r\nThe microservices architecture introduces many new challenges when dealing with complex systems. One of them is the high number of remote procedure calls and the cost associated to them. Among the techniques applied to amortize this cost, batching of requests has an important role. Instead of paying the price of one call for each interaction, many interactions are batched in only one call.\r\n\r\nWhile batching introduces performance enhancements, it also introduces complexity to the codebase. The common approach is to extract as much information as possible about what needs to be fetched, perform the batched fetch and extract the individual values to compose the final result. The steps need to be repeated many times depending on how complex is the final structure.\r\n\r\nAn example of batching using futures:\r\n\r\n```scala\r\ntracksService.get(trackIds).flatMap { tracks =>\r\n  val userIds = tracks.map(_.creator)\r\n  usersService.get(userIds).map { users =>\r\n    val userMap = userIds.zip(users).toMap\r\n    tracks.map { track =>\r\n      new EnrichedTrack(track, userMap(track.creator))\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis example has only one level of nested resources. In a complex system, it is common to have several levels:\r\n\r\n```\r\n• timeline\r\n  • track post\r\n    • track\r\n      • creator\r\n  • track repost\r\n    • track\r\n      • creator\r\n    • reposter\r\n  • playlist post\r\n    • playlist\r\n      • track ids\r\n      • creator\r\n  • playlist repost\r\n    • playlist\r\n      • track ids\r\n      • creator\r\n    • reposter\r\n  • comment\r\n    • user\r\n  • user follow\r\n    • follower\r\n    • followee\r\n```\r\n\r\nThis structure can also be part of a bigger structure that includes the user's data for instance. Given this scenario, the code that is capable of batching requests in an optimal way is really complex and hard to maintain.\r\n\r\n## Solution ##\r\n\r\nThe complexity comes mainly from declaring together **what** needs to be fetched and **how** it should be fetched. Clump offers an embedded Domain-Specific Language (DSL) that allows declaration of **what** needs to be fetched and an execution model that determines **how** the resources should be fetched.\r\n\r\nThe execution model applies three main optimizations:\r\n\r\n1. Batch requests when it is possible;\r\n2. Fetch from the multiple sources in parallel;\r\n3. Avoid fetching the same resource multiple times by using a cache.\r\n\r\nThe DSL is based on a monadic interface similar to ```Future```. It is a Free Monad, that produces a nested series of transformations without starting the actual execution. This is the characteristic that allows triggering of the execution separately from the definition of what needs to be fetched.\r\n\r\nThe execution model leverages on Applicative Functors to express the independence of computations. It exposes only ```join``` to the user but makes use of other applicative operations internally. This means that even without the user specifying what is independent, the execution model can apply optimizations.\r\n\r\n# Getting started #\r\n\r\nTo use clump, just add the dependency to the project's build configuration.\r\n\r\n__Important__: Change ```x.x.x``` with the latest version listed by the [CHANGELOG.md](https://github.com/getclump/clump/blob/master/CHANGELOG.md) file.\r\n\r\nSBT\r\n\r\n```scala\r\nlibraryDependencies ++= Seq(\r\n  \"io.getclump\" %% \"clump\" % \"x.x.x\"\r\n)\r\n```\r\n\r\nMaven\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>io.getclump</groupId>\r\n    <artifactId>clump</artifactId>\r\n    <version>x.x.x</version>\r\n</dependency>\r\n```\r\n\r\n# Usage #\r\n\r\n## Example ##\r\n\r\nExample usage of Clump:\r\n\r\n```scala\r\nimport io.getclump.Clump\r\n\r\n// Creates sources using the batched interfaces\r\nval tracksSource = Clump.source(tracksService.fetch)(_.id)\r\nval usersSource = Clump.source(usersService.fetch)(_.id)\r\n\r\ndef renderTrackPosts(userId: Long) = {\r\n\r\n  // Defines the clump\r\n  val clump: Clump[List[EnrichedTrack]] = enrichedTrackPosts(userId)\r\n\r\n  // Triggers execution\r\n  val future: Future[Option[List[EnrichedTrack]]] = clump.get\r\n\r\n  // Renders the response\r\n  future.map {\r\n    case Some(trackPosts) => render.json(trackPosts)\r\n    case None             => render.notFound\r\n  }\r\n}\r\n\r\n// Composes a clump with the user's track posts\r\ndef enrichedTrackPosts(userId: Long) =\r\n  for {\r\n    trackPosts <- Clump.future(timelineService.fetchTrackPosts(userId))\r\n    enrichedTracks <- Clump.traverse(trackPosts)(enrichedTrack(_))\r\n  } yield {\r\n    enrichedTracks\r\n  }\r\n\r\n// Composes an enriched track clump\r\ndef enrichedTrack(trackId: Long) =\r\n  for {\r\n    track <- tracksSource.get(trackId)\r\n    creator <- usersSource.get(track.creatorId)\r\n  } yield {\r\n    new EnrichedTrack(track, creator)\r\n  }\r\n```\r\n\r\nThe usage of ```renderTrackPosts``` produces only three remote procedure calls:\r\n\r\n1. Fetch the track posts list (from ```timelineService```);\r\n2. Fetch the metadata for all the tracks (from ```tracksService```);\r\n3. Fetch the user metadata for all the tracks' creators (from ```usersService```).\r\n\r\nThe final result can be ```notFound``` because the user can be found or not.\r\n\r\n## Sources ##\r\n\r\nSources represent the remote systems' batched interfaces. Clump offers some methods to create sources using different strategies.\r\n\r\n### Clump.source ###\r\n\r\nThe ```Clump.source``` method accepts a function that may return less elements than requested. The output can also be in a different order than the inputs, since the last parameter is a function that allows Clump to determine which is the input for each output.\r\n\r\n```scala\r\ndef fetch(ids: List[Int]): Future[List[User]] = ...\r\n\r\nval usersSource = Clump.source(fetch)(_.id)\r\n```\r\n\r\nIt is possible to create sources that have additional inputs, but the compiler isn't capable of inferring the input type for these cases. The solution is to use an explicit generic:\r\n\r\n```scala\r\ndef fetch(session: UserSession, ids: List[Int]): Future[List[User]] = ...\r\n\r\ndef usersSource(session: UserSession) = \r\n    Clump.source[List[Int]](fetch(session, _))(_.id)\r\n```\r\n\r\nWithout the explicit generic, the compiler outputs this error message:\r\n\r\n```\r\nmissing parameter type for expanded function ((x$1) => fetch(1, x$1))\r\n```\r\n\r\n### Clump.sourceFrom ###\r\n\r\nThe ```Clump.sourceFrom``` method accepts a function that returns a ```Map``` with the values for the found inputs.\r\n\r\n```scala\r\ndef fetch(ids: List[Int]): Future[Map[Int, User]] = ...\r\n\r\nval usersSource = Clump.sourceFrom(fetch)\r\n```\r\n\r\nIt is also possible to specify additional inputs for ```Clump.sourceFrom```:\r\n\r\n```scala\r\ndef fetch(session: UserSession, ids: List[Int]): Future[Map[Int, User]] = ...\r\n\r\ndef usersSource(session: UserSession) = \r\n    Clump.sourceFrom[List[Int]](fetch(session, _))\r\n```\r\n\r\n### Clump.sourceZip ###\r\n\r\nThe ```Clump.sourceZip``` methods accepts a function that produces a list of outputs for each provided input. The result must keep the same order as the inputs list.\r\n\r\n```scala\r\ndef fetch(ids: List[Int]): Future[List[User]] = ...\r\n\r\nval usersSource = Clump.sourceZip(fetch)\r\n```\r\n\r\n### Additional configurations ###\r\n\r\nSome services have a limitation on how many resources can be fetched in a single request. It is possible to define this limit for each source instance:\r\n\r\n```scala\r\nval usersSource = Clump.sourceZip(fetch).maxBatchSize(100)\r\n```\r\n\r\nThe source instance can be also configured to automatically retry failed fetches by using the ```maxRetries``` method. It receives a partial function that defines the number of retries for each type of exception. The default number of retries is zero.\r\n\r\n```scala\r\nval usersSource = \r\n    Clump.sourceZip(fetch).maxRetries {\r\n      case e: SomeException => 10\r\n    }\r\n```\r\n\r\n## Constants ##\r\n\r\nIt is possible to create Clump instances based on values.\r\n\r\nFrom a non-optional value:\r\n\r\n```scala\r\nval clump: Clump[Int] = Clump.value(111)\r\n```\r\n\r\nFrom an optional value:\r\n\r\n```scala\r\nval clump: Clump[Int] = Clump.value(Option(111))\r\n```\r\n\r\nFrom a future:\r\n\r\n```scala\r\n// This method is useful as a bridge between Clump and non-batched services.\r\nval clump: Clump[Int] = Clump.future(counterService.currentValueFor(111))\r\n```\r\n\r\nThe `future` method is overloaded to be able to receive both `Future[T]` and `Future[Option[T]]`.\r\n\r\nIt is possible to create a failed Clump instance:\r\n\r\n```scala\r\nval clump: Clump[Int] = Clump.exception(new NumberFormatException)\r\n```\r\n\r\nThere is a shortcut for a constant empty Clump:\r\n\r\n```scala\r\nval clump: Clump[Int] = Clump.empty\r\n```\r\n\r\n## Composition ##\r\n\r\nClump has a monadic interface similar to ```Future```.\r\n\r\nIt is possible to apply a simple transformation by using ```map```:\r\n\r\n```scala\r\nval intClump: Clump = Clump.value(1)\r\nval stringClump: Clump[String] = intClump.map(_.toString)\r\n```\r\n\r\nIf the transformation results on another Clump instance, it is possible to use ```flatMap```:\r\n\r\n```scala\r\nval clump: Clump[(Track, User)] =\r\n  tracksSource.get(trackId).flatMap { track =>\r\n    usersSource.get(track.id).map { user =>\r\n      (track, user)\r\n    }\r\n  }\r\n```\r\n\r\nThe ```join``` method produces a Clump that has a tuple with the values of two Clump instances:\r\n\r\n```scala\r\nval clump: Clump[(User, List[Track])] =\r\n    usersSource.get(userId).join(userTracksSource.get(userId))\r\n```\r\n\r\nThere are also methods to deal with collections. Use ```collect``` to transform a collection of Clump instances into a single Clump:\r\n\r\n```scala\r\nval userClumps: List[Clump[User]] = userIds.map(usersSource.get(_))\r\nval usersClump: Clump[List[User]] = Clump.collect(usersClump)\r\n```\r\n\r\nInstead of ```map``` and then ```collect```, it is possible to use the shortcut ```traverse```:\r\n\r\n```scala\r\nval usersClump: Clump[List[User]] = Clump.traverse(userIds)(usersSource.get(_))\r\n```\r\n\r\nIt is possible to use for-comprehensions as syntactic sugar to avoid having to write the compositions:\r\n\r\n```scala\r\nval trackClump: Clump[EnrichedTrack] =\r\n    for {\r\n      track <- tracksSource.get(trackId)\r\n      creator <- usersSource.get(track.creatorId)\r\n    } yield {\r\n      new EnrichedTrack(track, creator)\r\n    }\r\n```\r\n\r\n## Execution ##\r\n\r\nThe creation of Clump instances doesn't trigger calls to the remote services. The only exception is when the code explicitly uses ```Clump.future``` to invoke a service.\r\n\r\nTo trigger execution, it is possible to use ```get```:\r\n\r\n```scala\r\nval trackClump: Clump[EnrichedTrack] = ...\r\nval user: Future[Option[EnrichedTrack]] = trackClump.get\r\n```\r\n\r\nClump assumes that the remote services can return less elements than requested. That's why the result is an ```Option```, since the input's result may be missing.\r\n\r\nIt is possible to define a default value by using ```getOrElse```:\r\n\r\n```scala\r\nval trackClump: Clump[EnrichedTrack] = ...\r\nval user: Future[EnrichedTrack] = trackClump.getOrElse(unknownTrack)\r\n```\r\n\r\nIf it is guaranteed that the underlying service will always return results for all fetched inputs, it is possible to use ```apply```, that throws a ```NotFoundException``` if the result is empty:\r\n\r\n```scala\r\nval trackClump: Clump[EnrichedTrack] = ...\r\nval user1: Future[EnrichedTrack] = trackClump.apply()\r\nval user2: Future[EnrichedTrack] = trackClump() // syntactic sugar\r\n```\r\n\r\nWhen a Clump instance has a collection, it is possible to use the ```list``` method. It returns an empty collection if the result is ```None```:\r\n\r\n```scala\r\nval usersClump: Clump[List[User]] = Clump.traverse(userIds)(usersSource.get(_))\r\nval users: Future[List[User]] = usersClump.list\r\n```\r\n\r\n## Composition behavior ##\r\n\r\nThe composition of Clump instances takes in consideration that the sources may not return results for all requested inputs. It has a behavior similar to the relational databases' joins, where not found joined elements make the tuple be filtered-out.\r\n\r\n```scala\r\nval clump: Clump[(Track, User)]\r\n  for {\r\n    track <- tracksSource.get(111)\r\n    user <- usersSource.get(track.creator)\r\n  } yield (track, user)\r\n```\r\n\r\nIn this example, if the track's creator isn't found, the final result will be ```None```.\r\n\r\n```scala\r\nval future: Future[Option[(Track, User)]] = clump.get\r\nval result: Option[(Track, User)] = Await.result(future)\r\nrequire(result === None)\r\n```\r\n\r\nIf a nested clump is expected to be optional, it is possible to use the ```optional``` method to have a behavior similar to an outer join.\r\n\r\n```scala\r\nval clump: Clump[(Track, Option[User])]\r\n  for {\r\n    track <- tracksSource.get(111)\r\n    user <- usersSource.get(track.creator).optional\r\n  } yield (track, user)\r\n```\r\n\r\nAnother alternative is to define a fallback by using ```orElse```:\r\n\r\n```scala\r\nval clump: Clump[(Track, Option[User])]\r\n  for {\r\n    track <- tracksSource.get(111)\r\n    user <- usersSource.get(track.creator).orElse(usersSource.get(track.uploader))\r\n  } yield (track, user)\r\n```\r\n\r\n## Filtering ##\r\n\r\nThe behavior introduced by the optional fetch compositions allows defining of filtering conditions:\r\n\r\n```scala\r\nval clump: Clump[(Track, User)]\r\n  for {\r\n    track <- tracksSource.get(111) if(track.owner == currentUser)\r\n    user <- usersSource.get(track.creator)\r\n  } yield (track, user)\r\n```\r\n\r\n## Exception handling ##\r\n\r\nClump offers some mechanisms to deal with failed fetches.\r\n\r\nThe ```handle``` method defines a fallback value given an exception:\r\n\r\n```scala\r\nval clump: Clump[User] =\r\n    usersService.get(userId).handle {\r\n      case _: SomeException =>\r\n        defaultUser\r\n    }\r\n```\r\n\r\nIf the fallback value is another Clump instance, it is possible to use ```rescue```:\r\n\r\n```scala\r\nval clump: Clump[User] =\r\n    usersService.get(trackCreatorId).rescue {\r\n      case _: SomeException =>\r\n        usersService.get(trackUploaderId)\r\n    }\r\n```\r\n\r\n# Scala Futures #\r\n\r\nClump uses Twitter Futures by default, but it is possible to use Scala Futures by importing the ```FutureBridge```:\r\n\r\n```scala\r\nimport clump.FutureBridge._\r\n\r\nval userClump: Clump[User] = ...\r\nval future: scala.concurrent.Future[User] = userClump.get\r\n```\r\n\r\nIt provides bidirectional implicit conversions. \r\n\r\n# Internals #\r\n\r\nThis section explains how Clump works under the hood.\r\n\r\nThe codebase is relatively small. The only type explicitly exposed to the user is ```Clump```, but internally there are four in total:\r\n\r\n[Clump](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala) - Defines the public interface of Clump and represents the abstract syntactic tree (AST) for the compositions.\r\n\r\n[ClumpSource](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpSource.scala) - Represents the external systems' batched interfaces.\r\n\r\n[ClumpFetcher](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpFetcher.scala) - It has the logic to fetch from a ```ClumpSource```, maintains the implicit cache and implements the logic to retry failed fetches.\r\n\r\n[ClumpContext](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpContext.scala) - It is the execution model engine created automatically for each execution. It keeps the state by using a collection of ```ClumpFetcher```s.\r\n\r\nTake some time to read the code of these classes. It will help to have a broader view and understand the explanation that follows.\r\n\r\nLets see what happens when this example is executed:\r\n\r\n```scala\r\nval usersSource = Clump.source(usersService.fetch)(_.id)\r\nval tracksSource = Clump.source(tracksService.fetch)(_.id)\r\n\r\nval clump: Clump[List[EnrichedTrack]] =\r\n    Clump.traverse(trackIds) { trackId =>\r\n      for {\r\n        track <- tracksSource.get(trackId)\r\n        user <- usersSource.get(track.creatorId)\r\n      } yield {\r\n        new EnrichedTrack(track, user)\r\n      }\r\n    }\r\n\r\nval tracks: Future[List[Track]] = clump.list\r\n```\r\n\r\n## Sources creation\r\n\r\n```scala\r\nval usersSource = Clump.source(usersService.fetch)(_.id)\r\nval tracksSource = Clump.source(tracksService.fetch)(_.id)\r\n```\r\n\r\nThe ```ClumpSource``` instances are created using one of the shortcuts that the ```Clump``` object [provides](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L112). They don't hold any state and allow to create Clump instances representing the [fetch](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpSource.scala#L18). Clump uses the fetch function's [identity](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/FunctionIdentity.scala) to group requests and perform batched fetches, so it is possible to have multiple instances of the same source within a clump composition and execution.\r\n\r\n## Composition\r\n\r\n```scala\r\nval clump: Clump[List[EnrichedTrack]] =\r\n    Clump.traverse(trackIds) { trackId =>\r\n      ...\r\n    }\r\n```\r\n\r\nThe ```traverse``` method is used as a [shortcut](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L64) for ```map``` and then ```collect```, so this code could be rewritten as follows:\r\n\r\n```scala\r\nval clump: Clump[List[EnrichedTrack]] =\r\n    Clump.collect(trackIds.map { trackId => \r\n      ...\r\n    }\r\n```\r\n\r\nFor each ```trackId```, a for-comprehension is used to compose a Clump that has the ```EnrichedTrack```:\r\n\r\n```scala\r\n      for {\r\n        track <- tracksSource.get(trackId)\r\n        user <- usersSource.get(track.creatorId)\r\n      } yield {\r\n        new EnrichedTrack(track, user)\r\n      }\r\n```\r\n\r\nThe for-comprehension is actually just syntactic sugar using ```map``` and ```flatMap```, so this code is equivalent to:\r\n\r\n```scala\r\n      tracksSource.get(trackId).flatMap { track =>\r\n        usersSource.get(track.creatorId).map { user =>\r\n          new EnrichedTrack(track, user)\r\n        }\r\n      }\r\n```\r\n\r\nThere are three methods being used in this composition:\r\n\r\n1. ```get``` [creates](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpSource.scala#L17) a ```ClumpFetch``` instances that is the AST element [representing the fetch](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L131). It doesn't trigger the actual fetch, only uses the ```ClumpFetcher``` instance to produce a ```Future``` that will be [executed by](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpFetcher.scala#L17) the ```ClumpContext``` when the execution is triggered. \r\n\r\n2. ```flatMap``` creates a ```ClumpFlatMap``` instance [representing the operation](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L168). It just [composes a new future](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L174) that is based on the result of the initial Clump and the result of the nested Clump.\r\n\r\n3. ```map``` creates a ```ClumpMap``` instance [representing the map operation](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L161). It [composes a new future](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L164) by applying the specified transformation.\r\n\r\nNote that __any__ Clump composition creates a ```ClumpContext``` [implicitly](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L11) if it doesn't exist yet. The ```ClumpContext``` is maintained using a ```Local``` [value](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpContext.scala#L50), that is a [mechanism](https://github.com/twitter/util/blob/util-6.23.0/util-core/src/main/scala/com/twitter/util/Local.scala#L91) similar to a ```ThreadLocal``` but for asynchronous compositions.  \r\n\r\n## Execution\r\n\r\nNow comes the most important part. Until now, the compositions only create ```Clump*``` instances to represent the operations and produce futures that will be fulfilled when the execution is triggered. You probably have noticed that the Clump instances define three things:\r\n\r\n1. ```result``` that has the ```Future``` [result](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L47) for the operation\r\n2. ```upstream``` that [returns](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L45) the upstream Clump instances that were used as the basis for the composition\r\n3. ```downstream``` that [returns](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L46) the downstream Clump instances created as a result of the operation\r\n\r\nNote that ```downstream``` returns a ```Future[List[Clump[_]]]```, while ```upstream``` returns a ```List[Clump[_]]``` directly. This happens because ```downstream``` produces Clump instances that are available only after the ```upstream``` execution.\r\n\r\nThese methods are used by the ```ClumpContext``` to apply the execution model. It has a [collection](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpContext.scala#L10) with all ```ClumpFetcher``` instances in the composition.\r\n\r\nThis is the code that triggers the execution:\r\n\r\n```scala\r\nval tracks: Future[List[Track]] = clump.list\r\n```\r\n\r\nThe ```list``` method is just a [shortcut](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L35) to ease getting the value of Clump instances that have a collection. The actual execution is triggered by the ```get``` [method](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/Clump.scala#L38). It flushes the context and returns the Clump's result.\r\n\r\nThe [context flush](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpContext.scala#L20) is a recursive function that performs simple steps:\r\n\r\n* If there aren't Clump instances to be fetched, [stop the recursion](https://github.com/getclump/clump/blob/v0.0.7/src/main/scala/io/getclump/ClumpContext.scala#L22);\r\n* If there are Clump instances to be fetched\r\n  * Flush all the upstream instances of the current clumps;\r\n  * Perform all the fetches among the current Clump instances being executed.\r\n  * Flush all the downstream instances, since the pre-requisite to run the downstream is fulfilled (upstream already flushed). Note that the difference from the ```upstream``` flush is due the fact that ```downstream``` returns a future, but the semantic is the same.\r\n\r\nYou could consider this a depth-first, upstream-first traversal of the Clump graph.\r\n\r\nIn case you are wondering why we need this upstream mechanism since we have the Clump instance at hand and could start the execution from it: actually the instance used to trigger the execution isn't the \"root\" of the composition. For instance:\r\n\r\n```scala\r\nval clump: Clump[EnrichedTrack] =\r\n    tracksSource.get(trackId).flatMap { track =>\r\n      usersSource.get(track.creatorId).map { user =>\r\n        new EnrichedTrack(track, user)\r\n      }\r\n    }\r\n```\r\n\r\nThe clump instance will be a ```ClumpFlatMap```, not the ```ClumpFetch``` created by the ```tracksSource.get(trackId)``` call. This is the AST behind the clump instance:\r\n\r\n```\r\n                                   +----------> Empty                    \r\n                                   |Up                                   \r\n                            +------+-----+                               \r\n                            | ClumpFetch |                               \r\n               +----------> |  (line 2)  |                               \r\n               |Up          +------+-----+                               \r\n               |                   |Down                                 \r\n               |                   +----------> Empty                    \r\n       +-------+------+                                                  \r\n       | ClumpFlatMap |                                                  \r\nget--> |   (line 2)   |                                   +-------> Empty\r\n       +-------+------+                                   |Up            \r\n               |                                +---------+--+           \r\n               |                   +----------> | ClumpFetch |           \r\n               |                   |Up          |  (line 3)  |           \r\n               |Down        +------+-----+      +---------+--+           \r\n               +----------> |  ClumpMap  |                |Down          \r\n                            |  (line 3)  |                +-------> Empty\r\n                            +------+-----+                               \r\n                                   |Down                                 \r\n                                   +----------> Empty                    \r\n```\r\n\r\nThe steps to execute this composition happen as follows:\r\n\r\n* The execution is triggered by the ```get``` method on the ```ClumpFlatMap``` instance\r\n* The flush of ```ClumpFlatMap``` starts\r\n  * ```ClumpFlatMap``` upstream is flushed\r\n    * The flush of ```ClumpFetch``` starts\r\n      * Upstream is flushed and returns immediately (empty)\r\n      * The fetch is executed to fulfill the prerequisites to the downstream flush (upstream + fetch)\r\n      * Downstream is flushed and returns immediately (empty)\r\n  * ```ClumpFlatMap``` downstream is flushed\r\n    * The flush of ```ClumpMap``` starts\r\n      * Upstream is flushed\r\n        * The flush of the second ```ClumpFetch``` starts\r\n          * Upstream is flushed and returns immediately (empty)\r\n          * The fetch is executed\r\n          * Downstream is flushed and returns immediately (empty)\r\n      * Downstream is flushed and returns immediately (empty)\r\n\r\nNote that this example has only one Clump instance per flush phase, but normally there are multiple instances. This is what allows Clump to batch requests that are in the same flush phase.\r\n\r\n# Known limitations #\r\n\r\nThe execution model is capable of batching requests that are in the same level of the composition. For instance, this example produces only one fetch from ```usersSource```:\r\n\r\n```scala\r\nval clump: Clump[List[EnrichedTrack]] =\r\n    Clump.traverse(trackIds) { trackId =>\r\n      for {\r\n        track <- tracksSource.get(trackId)\r\n        user <- usersSource.get(track.creatorId)\r\n      } yield {\r\n        new EnrichedTrack(track, user)\r\n      }\r\n    }\r\n```\r\n\r\nThe next example has two fetches from ```usersSource```: one for the playlists' creators and other for the tracks' creators.\r\n\r\n```scala\r\nval clump: Clump[List[EnrichedPlaylist]] =\r\n    Clump.traverse(playlistIds) { playlistId =>\r\n      for {\r\n        playlist <- playlistsSource.get(playlistId)\r\n        creator <- usersSource.get(playlist.creator)\r\n        tracks <- \r\n          Clump.traverse(playlist.trackids) {\r\n            for {\r\n              track <- tracksSource.get(trackId)\r\n              user <- usersSource.get(track.creatorId)\r\n            } yield {\r\n              new EnrichedTrack(track, user)\r\n            }\r\n          }\r\n      } yield {\r\n        new EnrichedPlaylist(playlist, creator, tracks)\r\n      }\r\n    }\r\n```\r\n\r\nConsidering that they happen in different levels of the composition, the execution model will execute two batched fetches to ```usersSource```, not one. This limitation is alleviated by the implicit caching if the playlist and tracks have the same creator.\r\n\r\n# Acknowledgments #\r\n\r\nClump was inspired by the Twitter's Stitch project. The initial goal was to have a similar implementation, but the project evolved to provide an approach more adherent to some use-cases we have in mind. See [STITCH.md](https://github.com/getclump/clump/blob/master/STITCH.md) for more information about the differences between Stich and Clump.\r\n\r\nFacebook's [Haxl paper](http://community.haskell.org/~simonmar/papers/haxl-icfp14.pdf) and the Futurice's [blog post](http://futurice.com/blog/an-example-of-functional-design) about Jobba also were important sources for the development phase.\r\n\r\nThe project was initially built using SoundCloud's [Hacker Time](https://developers.soundcloud.com/blog/stop-hacker-time).\r\n\r\n# Versioning #\r\n\r\nClump adheres to Semantic Versioning 2.0.0. If there is a violation of this scheme, report it as a bug.Specifically, if a patch or minor version is released and breaks backward compatibility, that version should be immediately yanked and/or a new version should be immediately released that restores compatibility. Any change that breaks the public API will only be introduced at a major-version release.\r\n\r\n# License #\r\n\r\nSee the [LICENSE-LGPL](https://github.com/getclump/clump/blob/master/LICENSE-LGPL.txt) file for details.\r\n","google":"UA-59399147-1","note":"Don't delete this file! It's used internally to help with page regeneration."}